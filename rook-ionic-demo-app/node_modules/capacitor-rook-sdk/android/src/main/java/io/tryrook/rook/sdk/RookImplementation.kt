package io.tryrook.rook.sdk

import android.app.Activity
import android.content.Context
import android.health.connect.HealthPermissions
import android.util.Log
import com.getcapacitor.JSObject
import com.getcapacitor.PluginCall
import com.rookmotion.rook.sdk.RookConfigurationManager
import com.rookmotion.rook.sdk.RookEventManager
import com.rookmotion.rook.sdk.RookHealthPermissionsManager
import com.rookmotion.rook.sdk.RookHelpers
import com.rookmotion.rook.sdk.RookSummaryManager
import com.rookmotion.rook.sdk.RookYesterdaySyncManager
import com.rookmotion.rook.sdk.RookYesterdaySyncPermissions
import com.rookmotion.rook.sdk.domain.enums.HealthDataType
import com.rookmotion.rook.sdk.domain.enums.HealthPermission
import com.rookmotion.rook.sdk.domain.enums.SyncInstruction
import com.rookmotion.rook.sdk.domain.enums.SyncStatus
import com.rookmotion.rook.sdk.domain.environment.RookEnvironment
import com.rookmotion.rook.sdk.domain.model.RookConfiguration
import com.rookmotion.rook.sdk.framework.permission.RequestHealthConnectPermissionsActivity
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.SupervisorJob
import kotlinx.coroutines.launch
import java.lang.Exception
import java.time.LocalDate
import java.util.Date

private const val INIT_ERROR_MESSAGE = "Please first init Rook"

public class RookImplementation() {
    private var rookConfigurationManager: RookConfigurationManager? = null
    private var rookHealthPermissionsManager: RookHealthPermissionsManager? = null
    private var scope: CoroutineScope = CoroutineScope(SupervisorJob() + Dispatchers.Main)
    private var syncManager: RookSummaryManager? = null
    private var eventsManager: RookEventManager? = null
    private var rookSyncManager: RookYesterdaySyncManager? = null
    private var environmentConfig: RookEnvironment = RookEnvironment.SANDBOX
    private var uuid: String? = null
    private var pass: String? = null
    
    fun initRookConfigurationManager(context: Context) {
        rookConfigurationManager = RookConfigurationManager(context)
        rookHealthPermissionsManager = RookHealthPermissionsManager(rookConfigurationManager!!)
        syncManager = RookSummaryManager(rookConfigurationManager!!)
        eventsManager = RookEventManager(rookConfigurationManager!!)
        rookSyncManager = RookYesterdaySyncManager(context)
    }
    // MARK: - Configuration

    fun initRook(environment: String, clientUUID: String, password: String, call: PluginCall) {

        if (rookConfigurationManager == null) return

        val enableLogs = call.getBoolean("enableLogs", ) ?: false

        var rookEnvironment = RookEnvironment.SANDBOX
        if (environment == "production") rookEnvironment = RookEnvironment.PRODUCTION

        environmentConfig = rookEnvironment
        uuid = clientUUID
        pass = password

        val rookConfiguration = RookConfiguration(
            clientUUID= clientUUID,
            secretKey = password,
            environment = rookEnvironment
        )

        if (enableLogs) rookConfigurationManager!!.enableLocalLogs()

        rookConfigurationManager!!.setConfiguration(rookConfiguration)

        scope.launch {
            rookConfigurationManager!!.initRook().fold({
                val ret = JSObject()
                ret.put("result", true)
                call.resolve(ret)
            }, {
                call.reject(it.message)
            })
        }
    }

    fun updateUserId(userId: String, call: PluginCall) {
        scope.launch {
            if (rookConfigurationManager == null) { 
                call.reject(INIT_ERROR_MESSAGE);
                return@launch
            }
            
            rookConfigurationManager!!
                .updateUserID(userId)
                .fold({
                    val ret = JSObject()
                    ret.put("result", true)
                    call.resolve(ret)
                }, {
                    call.reject(it.message)
                })
        }
    }

    fun clearUserId(call: PluginCall) {
        if (rookConfigurationManager == null) {
            call.reject(INIT_ERROR_MESSAGE)
            return
        }

        rookConfigurationManager!!.clearUserID()
            .fold({
                val ret = JSObject()
                ret.put("result", true)
                call.resolve(ret)
            }, {
                call.reject(it.message)
            })
    }

    fun deleteUserFromRook(call: PluginCall) {
        scope.launch {
            if (rookConfigurationManager == null) {
                call.reject(INIT_ERROR_MESSAGE)
                return@launch
            }
            rookConfigurationManager!!.deleteUserFromRook()
                .fold({
                    val ret = JSObject()
                    ret.put("result", true)
                    call.resolve(ret)
                }, {
                    call.reject(it.message)
                })
        }
    }

    fun getUserId(call: PluginCall) {
        try {
            if (rookConfigurationManager == null) { 
                call.reject(INIT_ERROR_MESSAGE);
                return
            }
            val ret = JSObject()
            ret.put("userId", rookConfigurationManager!!.getUserID())
            call.resolve(ret)
        } catch (e: Exception) {
            call.reject("We couldn't get the user id",e)
        }
    }

    fun syncUserTimeZone(call: PluginCall) {
        scope.launch {
            if (rookConfigurationManager == null) {
                call.reject(INIT_ERROR_MESSAGE)
                return@launch;
            }

            rookConfigurationManager!!.syncUserTimeZone()
                .fold({
                    val ret = JSObject()
                    ret.put("result", true)
                    call.resolve(ret)
                }, {
                    call.reject(it.message)
                })
        }
    }

    fun checkAvailability(context: Context, call: PluginCall) {
        try {
            if (rookConfigurationManager == null) { 
                call.reject(INIT_ERROR_MESSAGE);
                return
            }
            
            val ret = JSObject()
            ret.put("result", RookHealthPermissionsManager.checkAvailability(context).toString());
            call.resolve(ret)
        } catch (e: Exception) {
            call.reject("We couldn't check the availability",e)
        }
    }

    // MARK: - Permissions

    fun requestAllHealthConnectPermissions(activity: Activity) {
        HealthConnectPermissionsActivity.launch(activity, HealthPermission.ALL)
    }

    fun requestAllPermissions(activity: Activity) {
        HealthConnectPermissionsActivity.launch(activity, HealthPermission.ALL)
    }

    fun openHealthConnectSettings(call: PluginCall) {
        scope.launch {
            if (rookConfigurationManager == null) {
                call.reject(INIT_ERROR_MESSAGE)
                return@launch
            }

            rookHealthPermissionsManager!!.openHealthConnectSettings()
                .fold({
                    val ret = JSObject()
                    ret.put("result", true)
                    call.resolve(ret)
                }, {
                    call.reject(it.message)
                })
        }
    }

    fun healthConnectHasPermissions(call: PluginCall) {
        scope.launch {
            if (rookConfigurationManager == null) { 
                call.reject(INIT_ERROR_MESSAGE);
                return@launch
            }
            
            rookHealthPermissionsManager!!.checkPermissions(HealthPermission.ALL).
                fold({
                    val ret = JSObject()
                    ret.put("result", it)
                    call.resolve(ret)
                }, {
                    call.reject(it.message)
                })
        }
    }

    fun requestAndroidBackgroundPermissions(context: Context, call: PluginCall) {
        try {
            if (rookConfigurationManager == null) { 
                call.reject(INIT_ERROR_MESSAGE);
                return
            }
            RookYesterdaySyncPermissions.requestAndroidPermissions(context)
            val ret = JSObject()
            ret.put("result", true);
            call.resolve(ret)
        } catch (e: Exception) {
            call.reject("We couldn't ask for android permissions", e)
        }
    }

    // MARK: - Summaries

    fun scheduleYesterdaySync(call: PluginCall) {
        try {
            if (rookConfigurationManager == null) { 
                call.reject(INIT_ERROR_MESSAGE);
                return
            }

            if (uuid.isNullOrEmpty() || pass.isNullOrEmpty()) { 
                call.reject(INIT_ERROR_MESSAGE);
                return
            }

            val doEnd = determineDoEndValue(call.getString("doOnEnd") ?: "")

            rookSyncManager!!.scheduleYesterdaySync(
                enableLogs = true,
                clientUUID = uuid!!,
                secretKey = pass!!,
                environment = environmentConfig,
                doOnEnd = doEnd
            )

            val ret = JSObject()
            ret.put("result", true);
            call.resolve(ret)
        } catch (e: Exception) {
            call.reject("We couldn't schedule to sync data", e)
        }
    }

    private fun determineDoEndValue(permissionString: String): SyncInstruction {
        return when (permissionString) {
            "oldest" -> SyncInstruction.SYNC_OLDEST
            "latest" -> SyncInstruction.SYNC_LATEST
            else -> SyncInstruction.NOTHING
        }
    }

    fun shouldSyncFor(call: PluginCall) {
        scope.launch {
            if (rookConfigurationManager == null) {
                call.reject(INIT_ERROR_MESSAGE)
            }

            val date = call.getString("date", "")!!
            val type = call.getString("type", "")!!

            RookHelpers.shouldSyncFor(
                getHealthDataType(type),
                RookDateTime.stringToLocalDate(date)
            ).fold({
                val ret = JSObject()
                ret.put("result", it)
                call.resolve(ret)
            }, {
                call.reject(it.message)
            })

        }
    }

    private fun getHealthDataType(type: String): HealthDataType {
        return  when (type) {
            "SLEEP_SUMMARY" -> HealthDataType.SLEEP_SUMMARY
            "PHYSICAL_SUMMARY" -> HealthDataType.PHYSICAL_SUMMARY
            "BODY_SUMMARY" -> HealthDataType.BODY_SUMMARY
            "PHYSICAL_EVENT" -> HealthDataType.PHYSICAL_EVENT
            "BLOOD_GLUCOSE_BODY_EVENT" -> HealthDataType.BLOOD_GLUCOSE_BODY_EVENT
            "BLOOD_PRESSURE_BODY_EVENT" -> HealthDataType.BLOOD_PRESSURE_BODY_EVENT
            "BODY_METRICS_EVENT" -> HealthDataType.BODY_METRICS_EVENT
            "HEART_RATE_BODY_EVENT" -> HealthDataType.HEART_RATE_BODY_EVENT
            "HEART_RATE_PHYSICAL_EVENT" -> HealthDataType.HEART_RATE_PHYSICAL_EVENT
            "HYDRATION_BODY_EVENT" -> HealthDataType.HYDRATION_BODY_EVENT
            "NUTRITION_BODY_EVENT" -> HealthDataType.NUTRITION_BODY_EVENT
            "OXYGENATION_BODY_EVENT" -> HealthDataType.OXYGENATION_BODY_EVENT
            "OXYGENATION_PHYSICAL_EVENT" -> HealthDataType.OXYGENATION_PHYSICAL_EVENT
            "TEMPERATURE_BODY_EVENT" -> HealthDataType.TEMPERATURE_BODY_EVENT
            else -> HealthDataType.SLEEP_SUMMARY
        }
    }

    fun syncYesterdaySummaries(call: PluginCall) {
        scope.launch {
            try {
                if (rookConfigurationManager == null) {
                    call.reject(INIT_ERROR_MESSAGE)
                }
                
                val result = syncManager!!.syncYesterdaySummaries()
                val ret = JSObject()
                ret.put("result", result);
                call.resolve(ret)
            } catch (e: Exception) {
                call.reject("We couldn't check health data",e)
            }
        }
    }

    fun syncSleepSummary(call: PluginCall) {
        scope.launch {
            if (rookConfigurationManager == null) {
                call.reject(INIT_ERROR_MESSAGE);
                return@launch
            }

            val date = call.getString("date", "")!!

            val result = syncManager!!.syncSleepSummary(
                RookDateTime.stringToLocalDate(date)
            )

            result.fold({
                val ret = JSObject()
                ret.put("result", it == SyncStatus.SYNCED)
                call.resolve(ret)
            }, {
                call.reject(it.message)
            })
        }
    }

    fun syncBodySummary(call: PluginCall) {
        scope.launch {
            if (rookConfigurationManager == null) {
                call.reject(INIT_ERROR_MESSAGE);
                return@launch
            }

            val date = call.getString("date", "")!!

            val result = syncManager!!.syncBodySummary(
                RookDateTime.stringToLocalDate(date)
            )

            result.fold({
                val ret = JSObject()
                ret.put("result", it == SyncStatus.SYNCED)
                call.resolve(ret)
            }, {
                call.reject(it.message)
            })
        }
    }

    fun syncPhysicalSummary(call: PluginCall) {
        scope.launch {
            if (rookConfigurationManager == null) {
                call.reject(INIT_ERROR_MESSAGE);
                return@launch
            }

            val date = call.getString("date")!!

            val result = syncManager!!.syncPhysicalSummary(
                RookDateTime.stringToLocalDate(date)
            )

            result.fold({
                val ret = JSObject()
                ret.put("result", it == SyncStatus.SYNCED)
                call.resolve(ret)
            }, {
                call.reject(it.message)
            })
        }
    }

    fun reSyncFailedSummaries(call: PluginCall) {
        scope.launch {
            if (rookConfigurationManager == null) {
                call.reject(INIT_ERROR_MESSAGE);
                return@launch
            }

            syncManager!!.syncPendingSummaries()
                .fold({
                    val ret = JSObject()
                    ret.put("result", true)
                    call.resolve(ret)
                }, {
                    call.reject(it.message)
                })
        }
    }

    // MARK: - Events
    fun syncPhysicalEvents(call: PluginCall) {
        scope.launch {
            if (rookConfigurationManager == null) {
                call.reject(INIT_ERROR_MESSAGE);
                return@launch
            }

            val date = call.getString("date", "")!!

            val result = eventsManager!!.syncPhysicalEvents(
                RookDateTime.stringToLocalDate(date)
            )

            result.fold({
                val ret = JSObject()
                ret.put("result", it == SyncStatus.SYNCED)
                call.resolve(ret)
            }, {
                call.reject(it.message)
            })
        }
    }

    fun syncBloodGlucoseEvents(call: PluginCall) {
        scope.launch {
            if (rookConfigurationManager == null) {
                call.reject(INIT_ERROR_MESSAGE);
                return@launch
            }

            val date = call.getString("date", "")!!

            val result = eventsManager!!.syncBloodGlucoseEvents(
                RookDateTime.stringToLocalDate(date)
            )

            result.fold({
                val ret = JSObject()
                ret.put("result", it == SyncStatus.SYNCED)
                call.resolve(ret)
            }, {
                call.reject(it.message)
            })
        }
    }

    fun syncBloodPressureEvents(call: PluginCall) {
        scope.launch {
            if (rookConfigurationManager == null) {
                call.reject(INIT_ERROR_MESSAGE);
                return@launch
            }

            val date = call.getString("date", "")!!

            val result = eventsManager!!.syncBloodPressureEvents(
                RookDateTime.stringToLocalDate(date)
            )

            result.fold({
                val ret = JSObject()
                ret.put("result", it == SyncStatus.SYNCED)
                call.resolve(ret)
            }, {
                call.reject(it.message)
            })
        }
    }

    fun syncBodyMetricsEvents(call: PluginCall) {
        scope.launch {
            if (rookConfigurationManager == null) {
                call.reject(INIT_ERROR_MESSAGE);
                return@launch
            }

            val date = call.getString("date","")!!

            val result = eventsManager!!.syncBodyMetricsEvents(
                RookDateTime.stringToLocalDate(date)
            )

            result.fold({
                val ret = JSObject()
                ret.put("result", it == SyncStatus.SYNCED)
                call.resolve(ret)
            }, {
                call.reject(it.message)
            })
        }
    }

    fun syncBodyHeartRateEvents(call: PluginCall) {
        scope.launch {
            if (rookConfigurationManager == null) {
                call.reject(INIT_ERROR_MESSAGE);
                return@launch
            }

            val date = call.getString("date", "")!!

            val result = eventsManager!!.syncBodyHeartRateEvents(RookDateTime.stringToLocalDate(date))

            result.fold({
                val ret = JSObject()
                ret.put("result", it == SyncStatus.SYNCED)
                call.resolve(ret)
            }, {
                call.reject(it.message)
            })
        }
    }

    fun syncPhysicalHeartRateEvents(call: PluginCall) {
        scope.launch {
            if (rookConfigurationManager == null) {
                call.reject(INIT_ERROR_MESSAGE);
                return@launch
            }

            val date = call.getString("date", "")!!

            val result = eventsManager!!.syncPhysicalHeartRateEvents(
                RookDateTime.stringToLocalDate(date)
            )

            result.fold({
                val ret = JSObject()
                ret.put("result", it == SyncStatus.SYNCED)
                call.resolve(ret)
            }, {
                call.reject(it.message)
            })
        }
    }

    fun syncHydrationEvents(call: PluginCall) {
        scope.launch {
            if (rookConfigurationManager == null) {
                call.reject(INIT_ERROR_MESSAGE);
                return@launch
            }

            val date = call.getString("date", "")!!

            val result = eventsManager!!.syncHydrationEvents(
                RookDateTime.stringToLocalDate(date)
            )

            result.fold({
                val ret = JSObject()
                ret.put("result", it == SyncStatus.SYNCED)
                call.resolve(ret)
            }, {
                call.reject(it.message)
            })
        }
    }

    fun syncNutritionEvents(call: PluginCall) {
        scope.launch {
            if (rookConfigurationManager == null) {
                call.reject(INIT_ERROR_MESSAGE);
                return@launch
            }

            val date = call.getString("date", "")!!

            val result = eventsManager!!.syncNutritionEvents(
                RookDateTime.stringToLocalDate(date)
            )

            result.fold({
                val ret = JSObject()
                ret.put("result", it == SyncStatus.SYNCED)
                call.resolve(ret)
            }, {
                call.reject(it.message)
            })
        }
    }

    fun syncBodyOxygenationEvents(call: PluginCall) {
        scope.launch {
            if (rookConfigurationManager == null) {
                call.reject(INIT_ERROR_MESSAGE);
                return@launch
            }

            val date = call.getString("date", "")!!

            val result = eventsManager!!.syncBodyOxygenationEvents(RookDateTime.stringToLocalDate(date))

            result.fold({
                val ret = JSObject()
                ret.put("result", it == SyncStatus.SYNCED)
                call.resolve(ret)
            }, {
                call.reject(it.message)
            })
        }
    }

    fun syncPhysicalOxygenationEvents(call: PluginCall) {
        scope.launch {
            if (rookConfigurationManager == null) {
                call.reject(INIT_ERROR_MESSAGE);
                return@launch
            }

            val date = call.getString("date", "")!!

            val result = eventsManager!!.syncPhysicalOxygenationEvents(
                RookDateTime.stringToLocalDate(date)
            )

            result.fold({
                val ret = JSObject()
                ret.put("result", it == SyncStatus.SYNCED)
                call.resolve(ret)
            }, {
                call.reject(it.message)
            })
        }
    }

    fun syncTemperatureEvents(call: PluginCall) {
        scope.launch {
            if (rookConfigurationManager == null) {
                call.reject(INIT_ERROR_MESSAGE);
                return@launch
            }

            val date = call.getString("date","")!!

            val result = eventsManager!!.syncTemperatureEvents(
                RookDateTime.stringToLocalDate(date)
            )

            result.fold({
                val ret = JSObject()
                ret.put("result", it == SyncStatus.SYNCED)
                call.resolve(ret)
            }, {
                call.reject(it.message)
            })
        }
    }

    fun syncPendingEvents(call: PluginCall) {
        scope.launch {
            if (rookConfigurationManager == null) {
                call.reject(INIT_ERROR_MESSAGE);
                return@launch
            }

            eventsManager!!.syncPendingEvents()
                .fold({
                    val ret = JSObject()
                    ret.put("result", true)
                    call.resolve(ret)
                }, {
                    call.reject(it.message)
                })
        }
    }
}
